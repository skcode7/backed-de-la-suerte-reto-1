{"version":3,"file":"node_modules_genexus_web-controls-library_dist_esm_gx-radio-group_entry_js.js","mappings":";;;;;;;;;;;;;;AAA6G;;AAE7G,sCAAsC,oBAAoB,4BAA4B,oCAAoC,gBAAgB,gBAAgB,kBAAkB,kBAAkB,eAAe,oBAAoB,aAAa,gCAAgC,oCAAoC,sCAAsC,kCAAkC,WAAW,OAAO,uBAAuB,wBAAwB,kDAAkD,+BAA+B,wBAAwB,kBAAkB,mCAAmC,0BAA0B,sBAAsB,qCAAqC,mBAAmB,eAAe;;AAEhtB;AACA;AACA,QAAQ,qDAAgB;AACxB,sBAAsB,qDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAC,CAAC,iDAAI,IAAI,yCAAyC,EAAE,qDAAC;AACtE;AACA,oBAAoB,OAAO,qDAAU;AACrC,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEwC","sources":["./node_modules/@genexus/web-controls-library/dist/esm/gx-radio-group.entry.js"],"sourcesContent":["import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-10623738.js';\n\nconst radioGroupCss = \".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden}.line-measuring{visibility:hidden;position:absolute}gx-radio-group{display:-ms-flexbox;display:flex;margin-top:var(--margin-top, 0);margin-right:var(--margin-right, 0);margin-bottom:var(--margin-bottom, 0);margin-left:var(--margin-left, 0);-ms-flex:1;flex:1}gx-radio-group[hidden]{display:none !important}gx-radio-group[hidden][invisible-mode=keep-space]{display:-ms-flexbox !important;display:flex !important;visibility:hidden}gx-radio-group[direction=vertical]{-ms-flex-direction:column;flex-direction:column}gx-radio-group[direction=horizontal]{-ms-flex-wrap:wrap;flex-wrap:wrap}\";\n\nconst RadioGroup = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.change = createEvent(this, \"change\", 7);\n        this.radios = [];\n        /**\n         * Specifies how the child `gx-radio-option` will be layed out.\n         * It supports two values:\n         *\n         * * `horizontal`\n         * * `vertical` (default)\n         */\n        this.direction = \"horizontal\";\n        /**\n         * This attribute lets you specify how this element will behave when hidden.\n         *\n         * | Value        | Details                                                                     |\n         * | ------------ | --------------------------------------------------------------------------- |\n         * | `keep-space` | The element remains in the document flow, and it does occupy space.         |\n         * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |\n         */\n        this.invisibleMode = \"collapse\";\n        /**\n         * This attribute lets you specify if the element is disabled.\n         * If disabled, it will not fire any user interaction related event\n         * (for example, click event).\n         */\n        this.disabled = false;\n    }\n    disabledChanged() {\n        this.setDisabled();\n    }\n    valueChanged() {\n        // this radio group's value just changed\n        // double check the button with this value is checked\n        if (this.value === undefined) {\n            // set to undefined\n            // ensure all that are checked become unchecked\n            this.radios\n                .filter(r => r.checked)\n                .forEach(radio => {\n                radio.checked = false;\n            });\n        }\n        else {\n            let hasChecked = false;\n            this.radios.forEach(radio => {\n                if (radio.value === this.value) {\n                    if (!radio.checked && !hasChecked) {\n                        // correct value for this radio\n                        // but this radio isn't checked yet\n                        // and we haven't found a checked yet\n                        // so CHECK IT!\n                        radio.checked = true;\n                    }\n                    else if (hasChecked && radio.checked) {\n                        // somehow we've got multiple radios\n                        // with the same value, but only one can be checked\n                        radio.checked = false;\n                    }\n                    // remember we've got a checked radio button now\n                    hasChecked = true;\n                }\n                else if (radio.checked) {\n                    // this radio doesn't have the correct value\n                    // and it's also checked, so let's uncheck it\n                    radio.checked = false;\n                }\n            });\n        }\n        if (this.didLoad) {\n            // emit the new value\n            this.change.emit({ value: this.value });\n        }\n    }\n    onRadioDidLoad(ev) {\n        const radio = ev.target;\n        this.radios.push(radio);\n        radio.name = this.name;\n        if (this.value !== undefined && radio.value === this.value) {\n            // this radio-group has a value and this\n            // radio equals the correct radio-group value\n            // so let's check this radio\n            radio.checked = true;\n        }\n        else if (this.value === undefined && radio.checked) {\n            // this radio-group does not have a value\n            // but this radio is checked, so let's set the\n            // radio-group's value from the checked radio\n            this.value = radio.value;\n        }\n        else if (radio.checked) {\n            // if it doesn't match one of the above cases, but the\n            // radio is still checked, then we need to uncheck it\n            radio.checked = false;\n        }\n    }\n    onRadioDidUnload(ev) {\n        const index = this.radios.indexOf(ev.target);\n        if (index > -1) {\n            this.radios.splice(index, 1);\n        }\n    }\n    onRadioSelect(ev) {\n        this.radios.forEach(radio => {\n            if (radio === ev.target) {\n                if (radio.value !== this.value) {\n                    this.value = radio.value;\n                }\n            }\n            else {\n                radio.checked = false;\n            }\n        });\n    }\n    setDisabled() {\n        this.radios.forEach(radio => {\n            radio.disabled = this.disabled || this.readonly;\n        });\n    }\n    componentDidLoad() {\n        this.setDisabled();\n        this.didLoad = true;\n    }\n    render() {\n        return (h(Host, { role: \"radiogroup\", \"data-readonly\": \"\" }, h(\"slot\", null)));\n    }\n    get element() { return getElement(this); }\n    static get watchers() { return {\n        \"disabled\": [\"disabledChanged\"],\n        \"value\": [\"valueChanged\"]\n    }; }\n};\nRadioGroup.style = radioGroupCss;\n\nexport { RadioGroup as gx_radio_group };\n"],"names":[],"sourceRoot":"webpack:///"}