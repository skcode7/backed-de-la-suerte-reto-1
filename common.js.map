{"version":3,"file":"common.js","mappings":";;;;;;;;;;;;;;AAAA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAE0D;;;;;;;;;;;;;;;;;;AChB1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAE0G;;;;;;;;;;;;;;;;ACpGrC;;AAErE;AACA;AACA,QAAQ,6DAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;ACtB/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEkC;;;;;;;;;;;;;;;;;;AC3CM;;AAExC;AACA,kDAAkD,qDAAC;AACnD;AACA;AACA;AACA,iCAAiC,wCAAwC;AACzE;AACA;;AAEkG;;;;;;;;;;;;;;;;ACXT;;AAEzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qEAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,QAAQ,qEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,IAAI,qEAAc;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;ACvEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B","sources":["./node_modules/@genexus/web-controls-library/dist/esm/_commonjsHelpers-7b8ed50b.js","./node_modules/@genexus/web-controls-library/dist/esm/css-variables-watcher-cf910941.js","./node_modules/@genexus/web-controls-library/dist/esm/grid-base-bc611296.js","./node_modules/@genexus/web-controls-library/dist/esm/highlightable-e5a00dd1.js","./node_modules/@genexus/web-controls-library/dist/esm/image-position-f497f3df.js","./node_modules/@genexus/web-controls-library/dist/esm/line-clamp-b4163b3c.js","./node_modules/@genexus/web-controls-library/dist/esm/swipeable-71a0e453.js"],"sourcesContent":["var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, basedir, module) {\n\treturn module = {\n\t  path: basedir,\n\t  exports: {},\n\t  require: function (path, base) {\n    return commonjsRequire();\n  }\n\t}, fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nexport { commonjsGlobal as a, createCommonjsModule as c };\n","function debounce(func, wait, immediate = false) {\n    let timeout;\n    return function (...args) {\n        const later = function () {\n            timeout = null;\n            if (!immediate) {\n                func.apply(this, args);\n            }\n        }.bind(this);\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(this, args);\n        }\n    };\n}\n/*  This functions overrides a method adding calls before (`before()`) and\n    after (`after()`)\n*/\nfunction overrideMethod(component, methodName, { before, after }) {\n    const oldMethod = component[methodName];\n    component[methodName] = () => {\n        if (before !== undefined) {\n            before();\n        }\n        if (oldMethod !== undefined) {\n            oldMethod.call(component);\n        }\n        if (after !== undefined) {\n            after();\n        }\n    };\n}\nfunction getFileNameWithoutExtension(filePath) {\n    /*  If the function is called in the same folder as the file,\n        lastIndexOf(\"/\") might return -1, but since we add 1 to the result, the\n        value of fileNameStartIndex will be 0.\n  \n        If lastIndexOf(\"/\") >= 0, it means that filePath has at least one \"/\" and\n        adding 1 to the result of the function will return the index where the\n        fileName starts.\n    */\n    const fileNameStartIndex = filePath.lastIndexOf(\"/\") + 1;\n    // We store the fileName that could have extension\n    const fileName = filePath.substring(fileNameStartIndex);\n    const extensionIndex = fileName.lastIndexOf(\".\");\n    // If the file does not have extension\n    if (extensionIndex === -1) {\n        return fileName;\n    }\n    // Returns the name between the last \"/\" and the last \".\" of the `fileName`\n    return fileName.substring(0, extensionIndex);\n}\n\nfunction cssVariablesWatcher(component, properties) {\n    const updatePropertiesFromCss = debounce(function () {\n        for (const prop of properties) {\n            const propCssValue = getComputedStyle(component.element)\n                .getPropertyValue(prop.cssVariableName)\n                .trim();\n            if (propCssValue && component[prop.propertyName] !== propCssValue) {\n                component[prop.propertyName] = propCssValue;\n            }\n        }\n    }, 100);\n    // Set up a MutationObserver to monitor changes on style and class attributes.\n    // When a change occurs on this attributes, the properties listed in\n    // properties are updated with their corresponding CSS variables values.\n    // The properties will be kept in sync with the CSS variables values.\n    // The properties must have the mutable flag set to true.\n    const classObserver = new MutationObserver((mutationsList) => {\n        for (const mutation of mutationsList) {\n            if (mutation.type === \"attributes\" &&\n                (mutation.attributeName === \"class\" ||\n                    mutation.attributeName === \"style\")) {\n                updatePropertiesFromCss();\n            }\n        }\n    });\n    // componentDidLoad, componentDidUpdate and componentDidUnload are overriden\n    // to start and end observing the mutations, and to update the properties values.\n    overrideMethod(component, \"componentDidLoad\", {\n        after: () => updatePropertiesFromCss(),\n        before: () => {\n            classObserver.observe(component.element, {\n                attributes: true,\n                childList: false,\n                subtree: false\n            });\n        }\n    });\n    overrideMethod(component, \"componentDidUpdate\", {\n        after: () => updatePropertiesFromCss()\n    });\n    overrideMethod(component, \"componentDidUnload\", {\n        before: () => classObserver.disconnect()\n    });\n}\n\nexport { cssVariablesWatcher as c, debounce as d, getFileNameWithoutExtension as g, overrideMethod as o };\n","import { m as makeHighlightable } from './highlightable-e5a00dd1.js';\n\nclass GridBaseHelper {\n    static init(component) {\n        makeHighlightable(component);\n    }\n    static hostData(cmp) {\n        return {\n            class: {\n                \"gx-grid-base\": true,\n                \"gx-grid-empty\": this.isEmptyGrid(cmp),\n                \"gx-grid-empty-loading\": cmp.loadingState === \"loading\" && cmp.recordCount <= 0,\n                \"gx-grid-loading\": cmp.loadingState === \"loading\"\n            }\n        };\n    }\n    static isEmptyGrid(cmp) {\n        return cmp.recordCount === 0 && cmp.loadingState === \"loaded\";\n    }\n}\nGridBaseHelper.GRID_BASE_CLASSNAME = \"gx-grid-base\";\n\nexport { GridBaseHelper as G };\n","const HIGHLIGHT_EVENT_NAME = \"highlight\";\nconst UNHIGHTLIGHT_EVENT_NAME = \"unhighlight\";\nconst HIGHLIGHT_CLASS_NAME = \"gx-highlighted\";\nlet isSetup = false;\nfunction makeHighlightable(component) {\n    if (component.highlightable) {\n        if (!isSetup) {\n            isSetup = true;\n            setup();\n        }\n        component.element.addEventListener(HIGHLIGHT_EVENT_NAME, (event) => {\n            event.stopPropagation();\n            component.element.classList.add(HIGHLIGHT_CLASS_NAME);\n        });\n        component.element.addEventListener(UNHIGHTLIGHT_EVENT_NAME, (event) => {\n            event.stopPropagation();\n            component.element.classList.remove(HIGHLIGHT_CLASS_NAME);\n        });\n    }\n}\nfunction setup() {\n    setupEvent(\"mousedown\", \"mouseup\", \"mouseout\");\n    setupEvent(\"touchstart\", \"touchend\", \"touchcancel\");\n}\nfunction setupEvent(startEventName, endEventName1, endEventName2) {\n    document.body.addEventListener(startEventName, startEvent => {\n        fireCustomEvent(HIGHLIGHT_EVENT_NAME, startEvent.target);\n        const mouseUpHandler = endEvent => {\n            fireCustomEvent(UNHIGHTLIGHT_EVENT_NAME, endEvent.target);\n            document.body.removeEventListener(endEventName1, mouseUpHandler);\n            document.body.removeEventListener(endEventName2, mouseUpHandler);\n        };\n        document.body.addEventListener(endEventName1, mouseUpHandler);\n        document.body.addEventListener(endEventName2, mouseUpHandler);\n    });\n}\nfunction fireCustomEvent(eventName, element) {\n    const highlightEvent = new CustomEvent(eventName, {\n        bubbles: true\n    });\n    element.dispatchEvent(highlightEvent);\n}\n\nexport { makeHighlightable as m };\n","import { h } from './index-10623738.js';\n\nfunction imagePositionRender(slots) {\n    return [slots.mainImage, slots.disabledImage, h(\"span\", null, slots.default)];\n}\nconst DEFAULT_IMAGE_POSITION = \"above\";\nfunction imagePositionClass(imagePosition) {\n    return `gx-image-position--${imagePosition || DEFAULT_IMAGE_POSITION}`;\n}\nconst hideMainImageWhenDisabledClass = \"gx-image-position--hide-main\";\n\nexport { imagePositionClass as a, hideMainImageWhenDisabledClass as h, imagePositionRender as i };\n","import { d as debounce, o as overrideMethod } from './css-variables-watcher-cf910941.js';\n\nfunction makeLinesClampable(component, contentContainerElementSelector, lineMeasuringElementSelector) {\n    // Used to know the sizes of the `content-container`\n    let contentContainerElement;\n    // Used to measure the line height\n    let lineMeasuringElement;\n    // Used to keep the state of the component\n    let contentContainerHeight = -1;\n    let lineMeasuringHeight = -1;\n    const applyLineClamp = debounce(function () {\n        requestAnimationFrame(function applyLineClampImpl() {\n            const currentContentContainerHeight = contentContainerElement.clientHeight;\n            const currentLineMeasuringHeight = lineMeasuringElement.clientHeight;\n            /*  If the container height and the line height have not been changed,\n                there is not need to update `component.maxLines`\n            */\n            if (contentContainerHeight == currentContentContainerHeight &&\n                lineMeasuringHeight == currentLineMeasuringHeight) {\n                return;\n            }\n            // Stores the current height of the content container and line measurement\n            contentContainerHeight = currentContentContainerHeight;\n            lineMeasuringHeight = currentLineMeasuringHeight;\n            // At least, one line will be displayed\n            component.maxLines = Math.max(Math.trunc(currentContentContainerHeight / lineMeasuringHeight), 1);\n        });\n    }, 100);\n    let resizeObserverContainer = null;\n    let resizeObserverLineHeight = null;\n    if (component.lineClamp) {\n        overrideMethod(component, \"componentDidLoad\", {\n            before: () => {\n                contentContainerElement = component.element.querySelector(contentContainerElementSelector);\n                lineMeasuringElement = component.element.querySelector(lineMeasuringElementSelector);\n                if (contentContainerElement === null || lineMeasuringElement === null) {\n                    return;\n                }\n                /*  If the `content-container` resizes, it checks if it is necessary to\n                    update `component.maxLines`\n                */\n                resizeObserverContainer = new ResizeObserver(() => {\n                    applyLineClamp();\n                });\n                /*  If the `font-size` changes, it checks if it is necessary to update\n                    `component.maxLines`\n                */\n                resizeObserverLineHeight = new ResizeObserver(() => {\n                    applyLineClamp();\n                });\n                // Observe the `content-container` and line height\n                resizeObserverContainer.observe(component.element);\n                resizeObserverLineHeight.observe(lineMeasuringElement);\n            }\n        });\n    }\n    overrideMethod(component, \"disconnectedCallback\", {\n        before: () => {\n            if (resizeObserverContainer !== null) {\n                resizeObserverContainer.disconnect();\n            }\n            if (resizeObserverLineHeight !== null) {\n                resizeObserverLineHeight.disconnect();\n            }\n        }\n    });\n    return {\n        applyLineClamp\n    };\n}\n\nexport { makeLinesClampable as m };\n","function makeSwipeable(comp) {\n    const element = comp.element;\n    element.addEventListener(\"touchstart\", startTouch);\n    element.addEventListener(\"touchmove\", moveTouch);\n    let initialX = null;\n    let initialY = null;\n    function startTouch(e) {\n        initialX = e.touches[0].clientX;\n        initialY = e.touches[0].clientY;\n    }\n    function moveTouch(e) {\n        if (initialX === null) {\n            return;\n        }\n        if (initialY === null) {\n            return;\n        }\n        const currentX = e.touches[0].clientX;\n        const currentY = e.touches[0].clientY;\n        const diffX = initialX - currentX;\n        const diffY = initialY - currentY;\n        comp.swipe.emit(event);\n        if (Math.abs(diffX) > Math.abs(diffY)) {\n            // sliding horizontally\n            if (diffX > 0) {\n                // swiped left\n                comp.swipeLeft.emit(event);\n            }\n            else {\n                // swiped right\n                comp.swipeRight.emit(event);\n            }\n        }\n        else {\n            // sliding vertically\n            if (diffY > 0) {\n                // swiped up\n                comp.swipeUp.emit(event);\n            }\n            else {\n                // swiped down\n                comp.swipeDown.emit(event);\n            }\n        }\n        initialX = null;\n        initialY = null;\n    }\n}\n\nexport { makeSwipeable as m };\n"],"names":[],"sourceRoot":"webpack:///"}