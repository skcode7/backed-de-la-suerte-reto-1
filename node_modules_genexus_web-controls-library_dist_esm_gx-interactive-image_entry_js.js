"use strict";
(self["webpackChunkgenexus_web_application"] = self["webpackChunkgenexus_web_application"] || []).push([["node_modules_genexus_web-controls-library_dist_esm_gx-interactive-image_entry_js"],{

/***/ 8074:
/*!*******************************************************************************************!*\
  !*** ./node_modules/@genexus/web-controls-library/dist/esm/gx-interactive-image.entry.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gx_interactive_image": () => (/* binding */ InteractiveImage)
/* harmony export */ });
/* harmony import */ var _index_10623738_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-10623738.js */ 9689);


const interactiveImageCss = ".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden}.line-measuring{visibility:hidden;position:absolute}gx-interactive-image{height:auto;width:auto;display:-ms-flexbox;display:flex;overflow:hidden}gx-interactive-image[hidden]{display:none !important}gx-interactive-image[hidden][invisible-mode=keep-space]{display:-ms-flexbox !important;display:flex !important;visibility:hidden}gx-interactive-image img{height:100%;width:100%}";

const InteractiveImage = class {
    constructor(hostRef) {
        (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        /**
         * True/False. If this property is true, the user can zoom in/out on the image.
         */
        this.enableZoom = false;
        /**
         * Indicates how much you can enlarge an image. (Percentage) _Note: 100% = Normal size_.
         */
        this.zoom = 100;
        /**
         * Lets you specify the image URL. *Requiered*
         */
        this.src = "";
        this.mouseOver = false;
        this.handleMouseMove = ev => {
            ev.preventDefault();
            this.mouseOver = true;
            this.zoomedPositionX = this.calculateZoomedPosition(ev.offsetX, ev.target.offsetWidth);
            this.zoomedPositionY = this.calculateZoomedPosition(ev.offsetY, ev.target.offsetHeight);
        };
        this.handleTouchMove = ev => {
            ev.preventDefault();
            this.mouseOver = true;
            const imgSize = {
                height: ev.target.offsetHeight,
                width: ev.target.offsetWidth
            };
            const touch = {
                X: ev.changedTouches[0].clientX - ev.target.x,
                Y: ev.changedTouches[0].clientY -
                    ev.target.parentNode.getBoundingClientRect().top
            };
            if (touch.X <= 0) {
                touch.X = 0;
            }
            else if (touch.X >= imgSize.width) {
                touch.X = imgSize.width;
            }
            if (touch.Y <= 0) {
                touch.Y = 0;
            }
            else if (touch.Y >= imgSize.height) {
                touch.Y = imgSize.height;
            }
            const moveImgPostion = {
                X: this.calculateZoomTouch(this.calculateZoomedPosition(touch.X, ev.target.offsetWidth), this.zoom),
                Y: this.calculateZoomTouch(this.calculateZoomedPosition(touch.Y, imgSize.height), this.zoom)
            };
            this.zoomedPositionX = moveImgPostion.X;
            this.zoomedPositionY = moveImgPostion.Y;
        };
        this.handleOverEnd = () => {
            this.mouseOver = false;
        };
    }
    calculateZoomedPosition(overPosition, elementSize) {
        const SCALE = this.zoom / 100;
        const HALF_SIZE_PERCENTAGE = 50;
        const HALF_SIZE_PIXELS = (elementSize * HALF_SIZE_PERCENTAGE) / 100;
        return -(overPosition - HALF_SIZE_PIXELS) * (SCALE - 1);
    }
    calculateZoomTouch(preCalculateValue, zoom) {
        const SCALE = zoom / 100;
        return preCalculateValue / SCALE;
    }
    checkZoomFeature() {
        if (this.enableZoom) {
            const img = this.element.querySelector("img");
            img.addEventListener("mousemove", this.handleMouseMove);
            img.addEventListener("touchmove", this.handleTouchMove);
            img.addEventListener("mouseout", this.handleOverEnd);
            img.addEventListener("touchend", this.handleOverEnd);
        }
        else {
            const img = this.element.querySelector("img");
            img.removeEventListener("mousemove", this.handleMouseMove);
            img.removeEventListener("touchmove", this.handleTouchMove);
            img.removeEventListener("mouseout", this.handleOverEnd);
            img.removeEventListener("touchend", this.handleOverEnd);
        }
    }
    fixZoomValue() {
        if (this.zoom < 100) {
            console.warn("Zoom value cannot be lower than 100");
            this.zoom = 100;
        }
    }
    componentWillLoad() {
        this.fixZoomValue();
    }
    componentDidLoad() {
        this.checkZoomFeature();
    }
    componentDidUpdate() {
        this.checkZoomFeature();
    }
    render() {
        this.fixZoomValue();
        return ((0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_0__.h)("img", { style: this.mouseOver
                ? {
                    "object-position": `${this.zoomedPositionX}px ${this.zoomedPositionY}px`,
                    transform: `scale(${this.zoom / 100})`
                }
                : {}, src: this.src }));
    }
    get element() { return (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }
};
InteractiveImage.style = interactiveImageCss;




/***/ })

}]);
//# sourceMappingURL=node_modules_genexus_web-controls-library_dist_esm_gx-interactive-image_entry_js.js.map