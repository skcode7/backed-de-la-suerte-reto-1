"use strict";
(self["webpackChunkgenexus_web_application"] = self["webpackChunkgenexus_web_application"] || []).push([["node_modules_genexus_web-controls-library_dist_esm_gx-chronometer_entry_js"],{

/***/ 6126:
/*!*************************************************************************************!*\
  !*** ./node_modules/@genexus/web-controls-library/dist/esm/gx-chronometer.entry.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gx_chronometer": () => (/* binding */ Chronometer)
/* harmony export */ });
/* harmony import */ var C_KBs_Koder_SupaBase_CSharpModel_mobile_Angular_Menu_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 4475);
/* harmony import */ var _index_10623738_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-10623738.js */ 9689);


var TimerState;

(function (TimerState) {
  TimerState["Running"] = "running";
  TimerState["Stopped"] = "stopped";
  TimerState["Reset"] = "reset";
})(TimerState || (TimerState = {}));

const chronometerCss = ".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden}.line-measuring{visibility:hidden;position:absolute}gx-chronometer{display:inline}gx-chronometer[hidden]{display:none !important}gx-chronometer[hidden][invisible-mode=keep-space]{display:inline !important;visibility:hidden}";
const Chronometer = class {
  constructor(hostRef) {
    (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    this.input = (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, "input", 7);
    this.change = (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, "change", 7);
    this.end = (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, "end", 7);
    this.tick = (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, "tick", 7);
    this.startedTime = 0;
    this.started = false;
    this.elapsedTime = 0;
    /**
     * This attribute lets you specify how this element will behave when hidden.
     *
     * | Value        | Details                                                                     |
     * | ------------ | --------------------------------------------------------------------------- |
     * | `keep-space` | The element remains in the document flow, and it does occupy space.         |
     * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |
     */

    this.invisibleMode = "collapse";
    /**
     * When the chronometer reaches this value,
     * MaxValueText will be shown instead of the Chronometer value.
     */

    this.maxValue = 0;
    /**
     * Time unit: (s) seconds or (ms) milliseconds for every time control Property.
     */

    this.unit = "s";
    /**
     * Defines the interval that the function onTick will be called.
     */

    this.interval = 1;
    /**
     * State of the Chronometer.
     */

    this.state = TimerState.Stopped;
    /**
     * The value of the control.
     */

    this.value = 0;
  }
  /**
   * Returns the id of the inner `input` element (if set).
   */


  getNativeInputId() {
    var _this = this;

    return (0,C_KBs_Koder_SupaBase_CSharpModel_mobile_Angular_Menu_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return _this.element;
    })();
  }

  componentWillLoad() {
    this.elapsedTime = this.value * this.getUnit();
  }

  componentDidUnload() {
    this.stop();
  }
  /**
   * Starts the Chronometer
   */


  start() {
    var _this2 = this;

    return (0,C_KBs_Koder_SupaBase_CSharpModel_mobile_Angular_Menu_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this2.started) {
        return;
      }

      _this2.started = true;
      _this2.startedTime = Date.now() - _this2.elapsedTime;

      _this2.updateElapsedTime();

      _this2.timer = window.setInterval(() => {
        _this2.updateElapsedTime();

        if (_this2.maxValue > 0 && _this2.elapsedTime >= _this2.maxValue * _this2.getUnit()) {
          _this2.end.emit();

          _this2.stop();
        }
      }, 1000);

      if (_this2.interval > 0) {
        _this2.eventTimer = window.setInterval(() => {
          _this2.tickHandler();
        }, _this2.interval * _this2.getUnit());
      }
    })();
  }
  /**
   * Stops the Chronometer
   */


  stop() {
    var _this3 = this;

    return (0,C_KBs_Koder_SupaBase_CSharpModel_mobile_Angular_Menu_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      window.clearInterval(_this3.eventTimer);
      window.clearInterval(_this3.timer);
      _this3.started = false;
      _this3.startedTime = 0;
    })();
  }
  /**
   * Stops and set to 0 the Chronometer.
   */


  reset() {
    var _this4 = this;

    return (0,C_KBs_Koder_SupaBase_CSharpModel_mobile_Angular_Menu_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this4.stop();

      _this4.value = 0;
      _this4.startedTime = 0;
      _this4.elapsedTime = 0;
    })();
  }

  handleChange() {
    this.input.emit();
    this.change.emit();
  }

  tickHandler() {
    this.tick.emit();
  }

  stateChanged(newState, oldState) {
    if (oldState === newState) {
      return;
    }

    switch (newState) {
      case TimerState.Running:
        this.start();
        break;

      case TimerState.Stopped:
        this.stop();
        break;

      case TimerState.Reset:
        this.reset();
        break;
    }
  }

  getUnit() {
    return this.unit === "s" ? 1000 : 1;
  }

  updateElapsedTime() {
    this.elapsedTime = Date.now() - this.startedTime;
    this.value = Math.floor(this.elapsedTime / this.getUnit());
  }

  render() {
    const time = Math.floor(this.elapsedTime / 1000);
    const maxVal = this.maxValue * this.getUnit();
    const maxValueReached = this.elapsedTime > maxVal && maxVal !== 0;
    return (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.h)("span", null, maxValueReached ? this.maxValueText : time);
  }

  get element() {
    return (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.g)(this);
  }

  static get watchers() {
    return {
      "value": ["handleChange"],
      "state": ["stateChanged"]
    };
  }

};
Chronometer.style = chronometerCss;


/***/ })

}]);
//# sourceMappingURL=node_modules_genexus_web-controls-library_dist_esm_gx-chronometer_entry_js.js.map