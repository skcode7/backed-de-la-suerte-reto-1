"use strict";
(self["webpackChunkgenexus_web_application"] = self["webpackChunkgenexus_web_application"] || []).push([["node_modules_genexus_web-controls-library_dist_esm_gx-select_entry_js"],{

/***/ 3085:
/*!********************************************************************************!*\
  !*** ./node_modules/@genexus/web-controls-library/dist/esm/gx-select.entry.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gx_select": () => (/* binding */ Select)
/* harmony export */ });
/* harmony import */ var C_KBs_Koder_SupaBase_CSharpModel_mobile_Angular_Menu_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 4475);
/* harmony import */ var _index_10623738_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-10623738.js */ 9689);


let autoSelectId = 0;

class SelectRender {
  constructor(component) {
    this.component = component;
    this.options = [];

    if (!this.selectId && !this.component.readonly) {
      this.selectId = this.component.element.id ? `${this.component.element.id}__select` : `gx-select-auto-id-${autoSelectId++}`;
    }
  }

  updateOptions(options) {
    this.options = options;
  }

  getNativeInputId() {
    return !this.component.readonly ? this.selectId : null;
  }

  getCssClasses() {
    const select = this.component;
    const classList = [];

    if (select.cssClass) {
      classList.push(select.cssClass);
    }

    if (select.readonly) {
      classList.push("readonly-select");
    } else {
      classList.push("normal-select");
    }

    return classList.join(" ");
  }

  getReadonlyTextContent() {
    const matchingOpts = this.options.filter(o => o.value === this.component.value);

    if (matchingOpts.length > 0) {
      return matchingOpts[0].innerText;
    }

    return "";
  }

  getValueFromEvent(event) {
    return event.target && event.target.value;
  }

  handleChange(event) {
    this.component.value = this.getValueFromEvent(event);
    this.component.input.emit(event);
  }

  render(anOptionHasBeenSelected) {
    if (this.component.readonly) {
      return (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
        class: this.getCssClasses(),
        "data-readonly": true
      }, (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.h)("span", null, this.getReadonlyTextContent()));
    } else {
      let datalistId;
      const attris = {
        "aria-disabled": this.component.disabled ? "true" : undefined,
        class: this.getCssClasses(),
        disabled: this.component.disabled,
        id: this.selectId,
        onChange: this.handleChange.bind(this),
        ref: select => {
          select.value = this.component.value;
        }
      };

      if (this.component.suggest) {
        datalistId = `${this.selectId}__datalist`;
      }

      return this.component.suggest ? [(0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.h)("gx-bootstrap", null), (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.h)("input", {
        list: datalistId,
        disabled: this.component.disabled,
        placeholder: this.component.placeholder,
        value: this.component.value,
        onChange: this.handleChange.bind(this)
      }), (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.h)("datalist", {
        id: datalistId
      }, this.options.map(({
        innerText,
        selected,
        value,
        disabled
      }) => (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.h)("option", {
        disabled: disabled,
        selected: selected,
        value: value
      }, innerText)))] : [(0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.h)("select", Object.assign({}, attris, {
        "data-readonly": true
      }), !anOptionHasBeenSelected && (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.h)("option", {
        hidden: true
      }, this.component.placeholder), this.options.map(({
        innerText,
        selected,
        value,
        disabled
      }) => (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.h)("option", {
        disabled: disabled,
        selected: selected,
        value: value
      }, innerText)))];
    }
  }

}

const selectCss = ".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden}.line-measuring{visibility:hidden;position:absolute}gx-select{margin-top:var(--margin-top, 0);margin-right:var(--margin-right, 0);margin-bottom:var(--margin-bottom, 0);margin-left:var(--margin-left, 0)}gx-select [data-readonly]{width:100%;height:100%}gx-select .readonly-select{display:-ms-flexbox;display:flex}gx-select .readonly-select>span{width:100%}gx-select .normal-select{border:unset}gx-select .normal-select,gx-select .normal-select:focus,gx-select .normal-select:active{outline:0}gx-select gx-select-option{display:none !important}gx-select .normal-select{-moz-text-align-last:start;text-align-last:start}gx-select option{text-align:start;-moz-text-align-last:start;text-align-last:start}gx-select .readonly-select{text-align:start}[align=center] gx-select .normal-select{-moz-text-align-last:center;text-align-last:center}[align=center] gx-select option{text-align:center;-moz-text-align-last:center;text-align-last:center}[align=center] gx-select .readonly-select{text-align:center}[align=right] gx-select .normal-select{-moz-text-align-last:end;text-align-last:end}[align=right] gx-select option{text-align:end;-moz-text-align-last:end;text-align-last:end}[align=right] gx-select .readonly-select{text-align:end}gx-select{display:block;-ms-flex:1;flex:1}gx-select[hidden]{display:none !important}gx-select[hidden][invisible-mode=keep-space]{display:block !important;visibility:hidden}";
const Select = class {
  constructor(hostRef) {
    (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    this.input = (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, "input", 7); // Used to show the placeholder when no options are selected

    this.anOptionHasBeenSelected = false;
    this.options = [];
    /**
     * This attribute lets you specify how this element will behave when hidden.
     *
     * | Value        | Details                                                                     |
     * | ------------ | --------------------------------------------------------------------------- |
     * | `keep-space` | The element remains in the document flow, and it does occupy space.         |
     * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |
     */

    this.invisibleMode = "collapse";
    /**
     * This attribute lets you specify if the element is disabled.
     * If disabled, it will not fire any user interaction related event
     * (for example, click event).
     */

    this.disabled = false;
    this.renderer = new SelectRender(this);
  }

  getChildOptions() {
    return Array.from(this.element.querySelectorAll("gx-select-option")).map(option => {
      return {
        disabled: option.disabled,
        innerText: option.innerText,
        selected: option.selected,
        value: option.value
      };
    });
  }

  updateOptions(options) {
    this.options = options;
    this.renderer.updateOptions(options);
  }

  valueChanged() {
    // the select value just changed
    this.anOptionHasBeenSelected = false;
    const optionsElement = Array.from(this.element.querySelectorAll("gx-select-option")); // let's set the new check state to all options
    // regardless if it is checked or not

    optionsElement.forEach(option => {
      if (option.value === this.value) {
        // the option value matches with the new select value
        // let's check this option
        option.selected = true;
        this.anOptionHasBeenSelected = true;
      } else {
        // the option value doesn't match
        // with the new select value
        // let's uncheck this option
        option.selected = false;
      } // if the new select value doesn't
      // match with any option, all options
      // will be unchecked

    }); // after set the new check state to all options
    // let's update the options list

    this.updateOptions(optionsElement.map(option => {
      return {
        disabled: option.disabled,
        innerText: option.innerText,
        selected: option.selected,
        value: option.value
      };
    }));

    if (this.didLoad) {
      // emit the new value
      this.input.emit({
        value: this.value
      });
    }
  }

  onSelectOptionDidLoad(ev) {
    const option = ev.target;

    if (this.value) {
      // check if the select has a setted value
      if (this.value === option.value) {
        // this select has a value and this
        // option equals the correct select value
        // so let's set this option as checked
        option.selected = true;
      } else {
        // if the option value does not match
        // with the select value,
        // the option will be unchecked
        // regardless if the option was
        // initialized as checked
        option.selected = false;
      }
    } else {
      // if the select does not have a value
      // let's look for options initialized as checked
      if (option.selected) {
        // this option was initialized as checked,
        // so let's set the select's value
        // equals to the checked option value
        this.value = option.value;
      } // If there is no option checked
      // and no value was set in the select,
      // it will keep undefined until any
      // change or checked option

    }

    this.updateOptions(this.getChildOptions());
  }

  onSelectOptionDidUnload() {
    this.updateOptions(this.getChildOptions());
  }

  onSelectOptionDisable() {
    this.updateOptions(this.getChildOptions());
  }

  onSelectOptionChange() {
    this.updateOptions(this.getChildOptions());
  }

  onSelectOptionSelect(ev) {
    this.options.forEach(option => {
      if (option === ev.target) {
        if (option.value !== this.value) {
          this.value = option.value;
        }
      } else {
        option.selected = false;
      }
    });
  }
  /**
   * Returns the id of the inner `input` element (if set).
   */


  getNativeInputId() {
    var _this = this;

    return (0,C_KBs_Koder_SupaBase_CSharpModel_mobile_Angular_Menu_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return _this.renderer.getNativeInputId();
    })();
  }

  componentDidLoad() {
    this.didLoad = true;
  }

  render() {
    return this.renderer.render(this.anOptionHasBeenSelected);
  }

  get element() {
    return (0,_index_10623738_js__WEBPACK_IMPORTED_MODULE_1__.g)(this);
  }

  static get watchers() {
    return {
      "value": ["valueChanged"]
    };
  }

};
Select.style = selectCss;


/***/ })

}]);
//# sourceMappingURL=node_modules_genexus_web-controls-library_dist_esm_gx-select_entry_js.js.map