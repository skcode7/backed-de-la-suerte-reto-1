{"version":3,"file":"node_modules_genexus_web-controls-library_dist_esm_gx-gauge_entry_js.js","mappings":"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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAC,aAAa,8FAA8F,+BAA+B,IAAI,aAAa,wBAAwB,yBAAyB,mDAAmD,qBAAqB;AACrS;AACA,oDAAoD,aAAa;AACjE,yCAAyC;AACzC,oCAAoC,IAAI,aAAa;AACrD,eAAe;AACf;AACA,oBAAoB,eAAe;AACnC;AACA;AACA,gBAAgB,qDAAC,UAAU;AAC3B;AACA,kCAAkC,SAAS;AAC3C;AACA,oCAAoC,uBAAuB;AAC3D,eAAe;AACf;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA,gBAAgB,qDAAC,WAAW;AAC5B,kCAAkC,SAAS;AAC3C;AACA;AACA,oCAAoC,uBAAuB;AAC3D,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C,wBAAwB;AACxB,6BAA6B;AAC7B,gBAAgB,qDAAC,CAAC,iDAAI,IAAI,uBAAuB,EAAE,qDAAC,UAAU,iCAAiC,EAAE,qDAAC,UAAU,sCAAsC,EAAE,qDAAC,UAAU,wBAAwB,EAAE,qDAAC,aAAa,gFAAgF,qBAAqB,sCAAsC,kCAAkC,qDAAC,UAAU;AAC/X;AACA,eAAe,EAAE,qDAAC,UAAU;AAC5B,0BAA0B,yBAAyB;AACnD,eAAe,yBAAyB,qDAAC,UAAU,kCAAkC,EAAE,qDAAC,WAAW,mEAAmE;AACtK;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAC,CAAC,iDAAI,IAAI,uBAAuB,EAAE,qDAAC,UAAU,wCAAwC,mBAAmB,WAAW,MAAM,qBAAqB,qDAAC,UAAU,sFAAsF,EAAE,qDAAC,WAAW;AAC9Q;AACA;AACA;AACA,aAAa,6CAA6C,iBAAiB,qDAAC,UAAU;AACtF,2BAA2B,oDAAoD;AAC/E,eAAe,qBAAqB,qDAAC,UAAU;AAC/C;AACA;AACA;AACA,aAAa,0CAA0C,IAAI,qDAAC,UAAU;AACtE,oCAAoC,qBAAqB;AACzD,eAAe,aAAa,qDAAC,UAAU,2BAA2B,EAAE,qDAAC,UAAU,yEAAyE,2FAA2F,qDAAC,UAAU,uCAAuC,0BAA0B,qDAAC,UAAU,2BAA2B,EAAE,qDAAC,UAAU,8BAA8B,yCAAyC,qDAAC,UAAU,mCAAmC,EAAE,qDAAC,WAAW,oBAAoB,kBAAkB,qDAAC,WAAW,oBAAoB;AAC3jB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO,qDAAU;AACrC,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAE6B","sources":["./node_modules/@genexus/web-controls-library/dist/esm/gx-gauge.entry.js"],"sourcesContent":["import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-10623738.js';\n\nconst gaugeCss = \".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden}.line-measuring{visibility:hidden;position:absolute}gx-gauge{--center-circle-text-color:rgba(44, 44, 44, 1);--center-circle-background-color:rgba(255, 255, 255, 0);--indicator-circle-background-color:rgba(44, 44, 44, 1);--stroke-linecap:initial;--stroke-animation-duration:1s;--value-text-color:rgba(44, 44, 44, 1);--value-text-background-color:rgba(255, 255, 255, 0.5);--max-value-background-color:rgba(255, 255, 255, 0.5);--max-value-text-color:rgba(40, 40, 40, 0.8);--min-value-background-color:rgba(255, 255, 255, 0.5);--min-value-text-color:rgba(40, 40, 40, 0.8);--indicator-line-background-color:rgba(44, 44, 44, 1);--empty-range-background-color:rgba(192, 192, 192, 0.5);display:-ms-flexbox;display:flex;position:relative;width:100%;margin-top:var(--margin-top, 0);margin-right:var(--margin-right, 0);margin-bottom:var(--margin-bottom, 0);margin-left:var(--margin-left, 0);-webkit-transition:background-color 0.25s, border-color 0.25s;transition:background-color 0.25s, border-color 0.25s}@-webkit-keyframes delay-animation-circle{0%{stroke-linecap:initial;stroke-dasharray:var(--stroke-dasharray-initial)}100%{stroke-linecap:initial;stroke-dasharray:var(--stroke-dasharray-initial)}}@keyframes delay-animation-circle{0%{stroke-linecap:initial;stroke-dasharray:var(--stroke-dasharray-initial)}100%{stroke-linecap:initial;stroke-dasharray:var(--stroke-dasharray-initial)}}@-webkit-keyframes loading-animation-circle{0%{stroke-dasharray:var(--stroke-dasharray-initial)}100%{stroke-dasharray:var(--stroke-dasharray)}}@keyframes loading-animation-circle{0%{stroke-dasharray:var(--stroke-dasharray-initial)}100%{stroke-dasharray:var(--stroke-dasharray)}}@-webkit-keyframes delay-animation-line{0%{width:0}100%{width:0}}@keyframes delay-animation-line{0%{width:0}100%{width:0}}@-webkit-keyframes loading-animation-line{0%{width:0}100%{width:var(--range-width)}}@keyframes loading-animation-line{0%{width:0}100%{width:var(--range-width)}}gx-gauge .line-gauge-container{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;width:100%;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content}gx-gauge .line-gauge-container .current-value-container{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;position:relative;width:100%;height:1.25em;-webkit-transition:height 0.25s;transition:height 0.25s}gx-gauge .line-gauge-container .current-value-container .current-value{height:80%;line-height:1em;font-weight:700;z-index:1;-webkit-transition:margin-left 0.25s, font-size 0.25s, background-color 0.25s, color 0.25s, -webkit-transform 0.25s;transition:margin-left 0.25s, font-size 0.25s, background-color 0.25s, color 0.25s, -webkit-transform 0.25s;transition:margin-left 0.25s, transform 0.25s, font-size 0.25s, background-color 0.25s, color 0.25s;transition:margin-left 0.25s, transform 0.25s, font-size 0.25s, background-color 0.25s, color 0.25s, -webkit-transform 0.25s;background-color:var(--value-text-background-color);color:var(--value-text-color)}gx-gauge .line-gauge-container .current-value-container .current-value.center-align{margin-left:var(--percentage, 0);-webkit-transform:translateX(-50%);transform:translateX(-50%)}gx-gauge .line-gauge-container .current-value-container .current-value.right-align{margin-left:100%;-webkit-transform:translateX(-100%);transform:translateX(-100%)}gx-gauge .line-gauge-container .current-value-container+.ranges-labels-and-indicator-container .ranges-and-labels-container{margin-top:4px}gx-gauge .line-gauge-container .ranges-labels-and-indicator-container{display:-ms-flexbox;display:flex;position:relative;width:100%;-webkit-transition:width 0.25s, height 0.25s;transition:width 0.25s, height 0.25s}gx-gauge .line-gauge-container .ranges-labels-and-indicator-container .indicator{display:block;position:absolute;height:100%;width:1.125%;z-index:1;-webkit-transition:margin-left 0.25s, background-color 0.25s, -webkit-transform 0.25s;transition:margin-left 0.25s, background-color 0.25s, -webkit-transform 0.25s;transition:margin-left 0.25s, transform 0.25s, background-color 0.25s;transition:margin-left 0.25s, transform 0.25s, background-color 0.25s, -webkit-transform 0.25s;background-color:var(--indicator-line-background-color)}gx-gauge .line-gauge-container .ranges-labels-and-indicator-container .indicator.center-align{margin-left:var(--percentage, 0);-webkit-transform:translateX(-50%);transform:translateX(-50%)}gx-gauge .line-gauge-container .ranges-labels-and-indicator-container .indicator.right-align{margin-left:100%;-webkit-transform:translateX(-100%);transform:translateX(-100%)}gx-gauge .line-gauge-container .ranges-labels-and-indicator-container .ranges-and-labels-container{position:relative;overflow:hidden;width:100%;background-color:var(--empty-range-background-color);-webkit-transition:background-color 0.25s;transition:background-color 0.25s}gx-gauge .line-gauge-container .ranges-labels-and-indicator-container .ranges-and-labels-container .range{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;width:var(--range-width);height:100%;position:absolute;-webkit-transition:width 0.25s;transition:width 0.25s;-webkit-animation:delay-animation-line calc(var(--child-number) * var(--stroke-animation-duration)), loading-animation-line var(--stroke-animation-duration) ease-in-out calc(var(--child-number) * var(--stroke-animation-duration));animation:delay-animation-line calc(var(--child-number) * var(--stroke-animation-duration)), loading-animation-line var(--stroke-animation-duration) ease-in-out calc(var(--child-number) * var(--stroke-animation-duration))}gx-gauge .line-gauge-container .ranges-labels-and-indicator-container .ranges-and-labels-container .labels-container{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;position:relative;width:100%;height:100%;overflow:unset}gx-gauge .line-gauge-container .ranges-labels-and-indicator-container .ranges-and-labels-container .labels-container .labels-subcontainer{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;width:100%;height:1.0625em}gx-gauge .line-gauge-container .ranges-labels-and-indicator-container .ranges-and-labels-container .labels-container .labels-subcontainer .range-label{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;position:absolute;line-height:1.125em;width:var(--range-width);max-height:100%;-webkit-filter:brightness(0.5);filter:brightness(0.5);text-align:center;overflow:hidden;-webkit-animation:delay-animation-line calc(var(--child-number) * var(--stroke-animation-duration)), loading-animation-line var(--stroke-animation-duration) ease-in-out calc(var(--child-number) * var(--stroke-animation-duration));animation:delay-animation-line calc(var(--child-number) * var(--stroke-animation-duration)), loading-animation-line var(--stroke-animation-duration) ease-in-out calc(var(--child-number) * var(--stroke-animation-duration));-webkit-transition:height 0.25s, width 0.25s, font-size 0.25s;transition:height 0.25s, width 0.25s, font-size 0.25s}gx-gauge .line-gauge-container .min-max-and-labels-container{display:-ms-flexbox;display:flex;-ms-flex-align:end;align-items:flex-end;position:relative;width:100%;height:1.25em;-webkit-transition:width 0.25s, height 0.25s, font-size 0.25s;transition:width 0.25s, height 0.25s, font-size 0.25s}gx-gauge .line-gauge-container .min-max-and-labels-container .min-max-values-container{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;width:100%;height:1em;font-weight:500;z-index:1;pointer-events:none}gx-gauge .line-gauge-container .min-max-and-labels-container .min-max-values-container .min-value,gx-gauge .line-gauge-container .min-max-and-labels-container .min-max-values-container .max-value{line-height:1em;pointer-events:all;-webkit-transition:background-color 0.25s, color 0.25s;transition:background-color 0.25s, color 0.25s}gx-gauge .line-gauge-container .min-max-and-labels-container .min-max-values-container .max-value{background-color:var(--max-value-background-color);color:var(--max-value-text-color)}gx-gauge .line-gauge-container .min-max-and-labels-container .min-max-values-container .min-value{background-color:var(--min-value-background-color);color:var(--min-value-text-color)}gx-gauge .line-gauge-container .min-max-and-labels-container .labels-container{display:-ms-flexbox;display:flex;-ms-flex-align:baseline;align-items:baseline;position:absolute;width:100%;height:1.125em;overflow:hidden}gx-gauge .line-gauge-container .min-max-and-labels-container .labels-container .labels-subcontainer{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;width:100%;height:1.0625em}gx-gauge .line-gauge-container .min-max-and-labels-container .labels-container .labels-subcontainer .range-label{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;position:absolute;line-height:1.125em;width:var(--range-width);max-height:100%;-webkit-filter:brightness(0.5);filter:brightness(0.5);text-align:center;overflow:hidden;-webkit-animation:delay-animation-line calc(var(--child-number) * var(--stroke-animation-duration)), loading-animation-line var(--stroke-animation-duration) ease-in-out calc(var(--child-number) * var(--stroke-animation-duration));animation:delay-animation-line calc(var(--child-number) * var(--stroke-animation-duration)), loading-animation-line var(--stroke-animation-duration) ease-in-out calc(var(--child-number) * var(--stroke-animation-duration));-webkit-transition:width 0.25s;transition:width 0.25s}gx-gauge .circle-gauge-container{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;-ms-flex-item-align:stretch;align-self:stretch;position:relative}gx-gauge .circle-gauge-container .svg-and-indicator-container{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;position:relative;width:100%;height:100%}gx-gauge .circle-gauge-container .svg-and-indicator-container svg{width:100%;height:100%;min-width:5px;min-height:5px}gx-gauge .circle-gauge-container .svg-and-indicator-container svg .circle-range{fill:none;stroke-linecap:var(--stroke-linecap, initial);-webkit-transition:stroke 0.25s, stroke-dasharray 0.25s;transition:stroke 0.25s, stroke-dasharray 0.25s;-webkit-animation:delay-animation-circle calc(var(--child-number) * var(--stroke-animation-duration)), loading-animation-circle var(--stroke-animation-duration) ease-in-out calc(var(--child-number) * var(--stroke-animation-duration));animation:delay-animation-circle calc(var(--child-number) * var(--stroke-animation-duration)), loading-animation-circle var(--stroke-animation-duration) ease-in-out calc(var(--child-number) * var(--stroke-animation-duration))}gx-gauge .circle-gauge-container .svg-and-indicator-container svg .background-circle{fill:none;stroke:var(--empty-range-background-color);-webkit-transition:stroke 0.25s;transition:stroke 0.25s}gx-gauge .circle-gauge-container .svg-and-indicator-container .indicator-container{position:absolute;width:100%;height:1.125%;-webkit-transition:-webkit-transform 0.25s;transition:-webkit-transform 0.25s;transition:transform 0.25s;transition:transform 0.25s, -webkit-transform 0.25s}gx-gauge .circle-gauge-container .svg-and-indicator-container .indicator-container .indicator{height:100%;-webkit-transition:background-color 0.25s;transition:background-color 0.25s;background-color:var(--indicator-circle-background-color)}gx-gauge .circle-gauge-container .current-value-container{position:absolute}gx-gauge .circle-gauge-container .current-value-container>span.current-value{display:block;line-height:100%;padding-bottom:0.125em;font-weight:900;-webkit-transition:background-color 0.25s, color 0.25s;transition:background-color 0.25s, color 0.25s;color:var(--center-circle-text-color);background-color:var(--center-circle-background-color)}\";\n\nconst Gauge = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.gxGaugeDidLoad = createEvent(this, \"gxGaugeDidLoad\", 7);\n        /**\n         * This property allows selecting the gauge type. The allowed values are `circle` or `line` (defautl).\n         */\n        this.type = \"line\";\n        /**\n         *  Set `true` to display the current value. Default is `false`.\n         *\n         */\n        this.showValue = false;\n        /**\n         *  Set `true` to display the minimum and maximum value. Default is `false`.\n         *\n         */\n        this.showMinMax = false;\n        /**\n         * The minimum value of the gauge\n         * 0 by Default\n         */\n        this.minValue = 0;\n        /**\n         * Allows specify the width of the circumference _(When gauge is circle type)_ or the width of the bar _(When gauge is Line type)_ in % relative the component size.\n         *\n         */\n        this.thickness = 10;\n        this.rangesChildren = [];\n        this.labelsOverflow = false;\n        this.lineCurrentValuePosition = \"Center\";\n        this.lineIndicatorPosition = \"Center\";\n        /*  Used to set to the gauge an observer when\n              - type == \"line\" or (`showValue` changes from `false` to `true` and\n                type == \"circle\").\n              - And the component has finished its rendering phase\n         */\n        this.shouldSetGaugeObserver = false;\n        this.maxValueAux = this.minValue;\n        this.totalAmount = 0;\n    }\n    /*  Used to connect and disconnect the resizeObserver based on the value of the\n        `type` property.\n     */\n    typeHandler(newValue) {\n        // We always disconnect the observer\n        this.disconnectObserver();\n        /*  If the type will change to \"line\" or `showValue == true` and the type\n            will change to \"circle\", we set the resizeObserver at the end of the\n            next rendering phase.\n         */\n        this.shouldSetGaugeObserver =\n            newValue === \"line\" || (this.showValue && newValue === \"circle\");\n    }\n    /*  Used to connect and disconnect the resizeObserver based on the value of the\n        `showValue` property.\n     */\n    showValueHandler(newValue) {\n        // We always disconnect the observer\n        this.disconnectObserver();\n        /*  If the `showValue` option will be turned on, we set the resizeObserver\n            at the end of the next rendering phase.\n         */\n        this.shouldSetGaugeObserver =\n            newValue && (this.type === \"line\" || this.type === \"circle\");\n    }\n    labelsPositionHandler(newValue, oldValue) {\n        // Used only in line gauge type\n        if (this.type === \"line\") {\n            /*  It means that the labels were inside the .range-container and the\n                thickness will decrease, so it might be necessary to change the\n                position of the labels, because they will overflow.\n             */\n            if (!this.labelsOverflow && newValue < oldValue) {\n                this.decideLabelsPosition();\n                /*  It means that the labels were outside of the .range-container and the\n                    thickness will increase, so it might be necessary to change the\n                    position of the labels, because they will not overflow anymore.\n                */\n            }\n            else if (this.labelsOverflow && newValue > oldValue) {\n                this.decideLabelsPosition();\n            }\n        }\n    }\n    onGaugeRangeDidLoad({ detail: childRange }) {\n        this.rangesChildren = [...this.rangesChildren, childRange];\n        this.totalAmount += childRange.amount;\n        // Possible improvement here. Check the approach applied in navbar.jsx line 103\n        childRange.element.addEventListener(\"gxGaugeRangeDidUnload\", () => {\n            this.rangesChildren = this.rangesChildren.filter(elementToSave => elementToSave != childRange);\n            this.totalAmount -= childRange.amount;\n        });\n        childRange.element.addEventListener(\"gxGaugeRangeDidUpdate\", () => {\n            const index = this.rangesChildren.findIndex(elementFinding => elementFinding === childRange);\n            this.rangesChildren.splice(index, 1, childRange);\n            this.totalAmount = 0;\n            for (const childInstance of this.rangesChildren) {\n                this.totalAmount += childInstance.amount;\n            }\n        });\n    }\n    /*  If showValue == true and gauge type == circle, it creates a\n        ResizeObserver to implement the font and indicator container\n        responsiveness\n    */\n    connectedCallback() {\n        if (this.showValue && this.type === \"circle\") {\n            this.setCircleGaugeObserver();\n        }\n    }\n    /*  If gauge type == line, it creates a ResizeObserver to implement\n        `current-value` and `indicator` centering responsiveness and range labels\n        responsiveness\n    */\n    componentDidLoad() {\n        if (this.type === \"line\") {\n            this.setLineGaugeObserver();\n        }\n    }\n    /*  After the render, it asks for 'getBoundingClientRect()' and centers the\n        'current-value' in line gauge type\n    */\n    componentDidRender() {\n        if (this.showValue && this.type === \"line\") {\n            this.setValueAndIndicatorPosition();\n        }\n        if (this.shouldSetGaugeObserver) {\n            if (this.type == \"line\") {\n                this.setLineGaugeObserver();\n            }\n            else {\n                this.setCircleGaugeObserver();\n            }\n            this.shouldSetGaugeObserver = false;\n        }\n    }\n    disconnectedCallback() {\n        this.disconnectObserver();\n    }\n    /*  Preconditions:\n          this.showValue === True\n          this.type === \"circle\"\n     */\n    setCircleGaugeObserver() {\n        this.watchForItemsObserver = new ResizeObserver(() => {\n            const fontSize = Math.min(this.SVGcircle.getBoundingClientRect().height, this.SVGcircle.getBoundingClientRect().width) / 2.5;\n            // Updates the font size\n            this.circleCurrentValue.style.fontSize = `${fontSize}px`;\n        });\n        // Observe the gauge\n        this.watchForItemsObserver.observe(this.element);\n    }\n    /*  Preconditions:\n          this.type === \"line\"\n          The component has finished its rendering phase\n     */\n    setLineGaugeObserver() {\n        this.watchForItemsObserver = new ResizeObserver(() => {\n            if (this.showValue) {\n                this.setValueAndIndicatorPosition();\n            }\n            this.decideLabelsPosition();\n        });\n        // Observe the `labels-subcontainer` in the line gauge type\n        this.watchForItemsObserver.observe(this.labelsSubContainer);\n    }\n    disconnectObserver() {\n        if (this.watchForItemsObserver !== undefined) {\n            this.watchForItemsObserver.disconnect();\n            this.watchForItemsObserver = undefined;\n        }\n    }\n    // If maxValue is undefined, it defines the maxValue as the sum of the amounts plus minValue\n    updateMaxValueAux() {\n        this.maxValueAux =\n            this.maxValue === undefined\n                ? this.minValue + this.totalAmount\n                : this.maxValue;\n    }\n    calcThickness() {\n        return typeof this.thickness === \"number\" &&\n            this.thickness > 0 &&\n            this.thickness <= 99\n            ? this.thickness\n            : 10;\n    }\n    calcPercentage() {\n        return this.value <= this.minValue\n            ? 0\n            : ((this.value - this.minValue) * 100) /\n                (this.maxValueAux - this.minValue);\n    }\n    /*  In the line gauge type, this functions correctly aligns the\n        'current-value' to the center of the 'indicator', even if the indicator\n        has low or high percentage value. Also, it makes to not overflow the\n        'indicator' from his container when he has low or high values.\n    */\n    setValueAndIndicatorPosition() {\n        const percentage = this.calcPercentage() >= 100 ? 100 : this.calcPercentage();\n        // This does not include the gauge padding\n        const gaugeWidth = this.linearCurrentValueContainer.getBoundingClientRect()\n            .width;\n        const distanceToTheValueCenter = (gaugeWidth / 100) * percentage;\n        // - - - - - - - - - - -  Current value positioning  - - - - - - - - - - -\n        const spanHalfWidth = this.linearCurrentValue.getBoundingClientRect().width / 2;\n        // The span is near the left side\n        if (distanceToTheValueCenter - spanHalfWidth < 0) {\n            this.lineCurrentValuePosition = \"Left\";\n            // The span is near the right side\n        }\n        else if (distanceToTheValueCenter + spanHalfWidth > gaugeWidth) {\n            this.lineCurrentValuePosition = \"Right\";\n            // The span is in an intermediate position\n        }\n        else {\n            this.lineCurrentValuePosition = \"Center\";\n        }\n        // - - - - - - - - - - - -  Indicator positioning  - - - - - - - - - - - -\n        const indicatorHalfWidth = this.linearIndicator.getBoundingClientRect().width / 2;\n        // The indicator is near the left side\n        if (distanceToTheValueCenter - indicatorHalfWidth < 0) {\n            this.lineIndicatorPosition = \"Left\";\n            // The indicator is near the right side\n        }\n        else if (distanceToTheValueCenter + indicatorHalfWidth > gaugeWidth) {\n            this.lineIndicatorPosition = \"Right\";\n            // The indicator is in an intermediate position\n        }\n        else {\n            this.lineIndicatorPosition = \"Center\";\n        }\n    }\n    decideLabelsPosition() {\n        // This only happens when the component has not yet been rendered to\n        // get the `labelsSubContainer` reference\n        if (this.labelsOverflow && this.labelsSubContainer == undefined) {\n            return;\n        }\n        const fontSize = this.labelsSubContainer.getBoundingClientRect().height;\n        // Depending on the current fontSize, it decides the position where\n        // the labels will be placed\n        if (fontSize > this.calcThickness() * 2) {\n            this.labelsOverflow = true;\n        }\n        else {\n            this.labelsOverflow = false;\n        }\n    }\n    addCircleRanges({ amount, color }, position, radius, childNumber // Identifies the number of child to animate it at the start\n    ) {\n        const FULL_CIRCLE_RADIANS = 2 * Math.PI;\n        const ROTATION_FIX = -90;\n        const circleLength = FULL_CIRCLE_RADIANS * radius;\n        const range = this.maxValueAux - this.minValue;\n        const valuePercentage = amount / range;\n        return (h(\"circle\", { class: \"circle-range\", r: radius, cx: \"50%\", cy: \"50%\", stroke: color, \"stroke-dasharray\": `${circleLength * valuePercentage}, ${circleLength}`, transform: `rotate(${position + ROTATION_FIX} 50,50)`, \"data-amount\": amount, \"stroke-width\": `${this.calcThickness()}%`, style: {\n                \"--child-number\": childNumber,\n                \"--stroke-dasharray-initial\": `0, ${circleLength}`,\n                \"--stroke-dasharray\": `${circleLength *\n                    valuePercentage}, ${circleLength}`\n            } }));\n    }\n    addLineRanges({ amount, color }, position, childNumber // Identifies the number of child to animate it at the start\n    ) {\n        const range = this.maxValueAux - this.minValue;\n        return (h(\"div\", { class: \"range\", style: {\n                \"background-color\": color,\n                \"margin-left\": `${position}%`,\n                \"--child-number\": childNumber,\n                \"--range-width\": `${(amount * 100) / range}%`\n            } }));\n    }\n    addLineRangesLabels({ amount, color, name }, position, childNumber // Identifies the number of child to animate it at the start\n    ) {\n        const range = this.maxValueAux - this.minValue;\n        return (h(\"span\", { class: \"range-label\", style: {\n                \"margin-left\": `${position}%`,\n                color: color,\n                \"--child-number\": childNumber,\n                \"--range-width\": `${(amount * 100) / range}%`\n            } }, name));\n    }\n    renderCircle(childRanges) {\n        const FULL_CIRCLE_RADIO = 100 / 2;\n        const svgRanges = [];\n        const ONE_PERCENT_OF_CIRCLE_DREGREE = 3.6;\n        const radius = FULL_CIRCLE_RADIO - this.calcThickness() / 2;\n        const ROTATION_FIX = 90; // Used to correct the rotation\n        this.totalAmount = 0;\n        for (let i = childRanges.length - 1; i >= 0; i--) {\n            this.totalAmount += childRanges[i].amount;\n        }\n        this.updateMaxValueAux();\n        const range = this.maxValueAux - this.minValue;\n        let positionInGauge = 0;\n        for (let i = 0; i < childRanges.length; i++) {\n            svgRanges.push(this.addCircleRanges(childRanges[i], positionInGauge, radius, i.toString()));\n            positionInGauge += (360 * childRanges[i].amount) / range;\n        }\n        const rotation = this.calcPercentage() == 100\n            ? `rotate(${359.5 + ROTATION_FIX}deg)`\n            : `rotate(${this.calcPercentage() * ONE_PERCENT_OF_CIRCLE_DREGREE +\n                ROTATION_FIX}deg)`;\n        return (h(Host, { \"data-readonly\": true }, h(\"div\", { class: \"circle-gauge-container\" }, h(\"div\", { class: \"svg-and-indicator-container\" }, h(\"svg\", { viewBox: \"0 0 100 100\" }, h(\"circle\", { class: \"background-circle\", r: radius, cx: \"50%\", cy: \"50%\", \"stroke-width\": `${this.calcThickness()}%`, ref: el => (this.SVGcircle = el) }), svgRanges), this.showValue && (h(\"div\", { class: \"indicator-container\", style: {\n                transform: rotation\n            } }, h(\"div\", { class: \"indicator\", style: {\n                width: `${this.calcThickness() + 2}%`\n            } })))), this.showValue && (h(\"div\", { class: \"current-value-container\" }, h(\"span\", { class: \"current-value\", ref: el => (this.circleCurrentValue = el) }, this.value))))));\n    }\n    renderLine(childRanges) {\n        const divRanges = [];\n        const divRangesLabel = [];\n        this.totalAmount = 0;\n        for (let i = childRanges.length - 1; i >= 0; i--) {\n            this.totalAmount += childRanges[i].amount;\n        }\n        this.updateMaxValueAux();\n        const range = this.maxValueAux - this.minValue;\n        let positionInGauge = 0;\n        for (let i = 0; i < childRanges.length; i++) {\n            divRanges.push(this.addLineRanges(childRanges[i], positionInGauge, i.toString()));\n            divRangesLabel.push(this.addLineRangesLabels(childRanges[i], positionInGauge, i.toString()));\n            positionInGauge += (100 * childRanges[i].amount) / range;\n        }\n        const percentage = this.calcPercentage() >= 100 ? 100 : this.calcPercentage();\n        return (h(Host, { \"data-readonly\": true }, h(\"div\", { class: \"line-gauge-container\", style: { \"--percentage\": `${percentage}%` } }, this.showValue && (h(\"div\", { class: \"current-value-container\", ref: el => (this.linearCurrentValueContainer = el) }, h(\"span\", { class: {\n                \"current-value\": true,\n                \"center-align\": this.lineCurrentValuePosition === \"Center\",\n                \"right-align\": this.lineCurrentValuePosition === \"Right\"\n            }, ref: el => (this.linearCurrentValue = el) }, this.value))), h(\"div\", { class: \"ranges-labels-and-indicator-container\", style: {\n                height: `${2 * this.calcThickness() + (this.showValue ? 4 : 0)}px`\n            } }, this.showValue && (h(\"div\", { class: {\n                indicator: true,\n                \"center-align\": this.lineIndicatorPosition === \"Center\",\n                \"right-align\": this.lineIndicatorPosition === \"Right\"\n            }, ref: el => (this.linearIndicator = el) })), h(\"div\", { class: \"ranges-and-labels-container\", style: {\n                \"border-radius\": `${this.calcThickness()}px`\n            } }, divRanges, h(\"div\", { class: \"labels-container\" }, h(\"div\", { class: \"labels-subcontainer\", ref: el => (this.labelsSubContainer = el) }, !this.labelsOverflow && divRangesLabel)))), (this.labelsOverflow || this.showMinMax) && (h(\"div\", { class: \"min-max-and-labels-container\" }, this.labelsOverflow && (h(\"div\", { class: \"labels-container\" }, h(\"div\", { class: \"labels-subcontainer\" }, divRangesLabel))), this.showMinMax && (h(\"div\", { class: \"min-max-values-container\" }, h(\"span\", { class: \"min-value\" }, this.minValue), h(\"span\", { class: \"max-value\" }, this.maxValueAux))))))));\n    }\n    render() {\n        const childRanges = Array.from(this.element.querySelectorAll(\"gx-gauge-range\"));\n        if (this.type === \"circle\") {\n            return this.renderCircle(childRanges);\n        }\n        else if (this.type === \"line\") {\n            return this.renderLine(childRanges);\n        }\n        else {\n            // tslint:disable-next-line:no-console\n            console.warn(\"Error rendering component. Invalid type of gauge in \", this.element);\n        }\n    }\n    get element() { return getElement(this); }\n    static get watchers() { return {\n        \"type\": [\"typeHandler\"],\n        \"showValue\": [\"showValueHandler\"],\n        \"thickness\": [\"labelsPositionHandler\"]\n    }; }\n};\nGauge.style = gaugeCss;\n\nexport { Gauge as gx_gauge };\n"],"names":[],"sourceRoot":"webpack:///"}